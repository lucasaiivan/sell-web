---
applyTo: '**'
---

# Gu√≠a de Desarrollo - Flutter Web

## üéØ Tecnolog√≠as Base
- **Framework**: Flutter Web
- **Arquitectura**: Clean Architecture (estrictamente)
- **Gesti√≥n de Estado**: Provider
- **Dise√±o**: Material 3

## üèóÔ∏è Arquitectura y Estructura

### Clean Architecture
- Mantener separaci√≥n clara entre capas (presentation, domain, data)
- Aplicar principios SOLID
- Utilizar interfaces para abstraer dependencias
- Provider para inyecci√≥n de dependencias y manejo de estados

### Organizaci√≥n de Carpetas
```
lib/
‚îú‚îÄ‚îÄ core/           # Widgets y utilidades reutilizables
‚îú‚îÄ‚îÄ data/           # Implementaciones de repositorios
‚îú‚îÄ‚îÄ domain/         # Entidades, repositorios y casos de uso
‚îî‚îÄ‚îÄ presentation/   # UI, p√°ginas y providers
```

## üé® Dise√±o y UX

### Material 3
- Implementar gu√≠as de dise√±o de Material 3
- Soporte completo para tema claro/oscuro din√°mico
- Aplicar buenas pr√°cticas de UX
- Componentes consistentes y accesibles

### Componentes Reutilizables
- **[core]**: Widgets b√°sicos reutilizables
- **[ComponentApp]**: Componentes espec√≠ficos (buttons, textButtons, inputs, etc.)
- Evitar duplicaci√≥n de c√≥digo
- Mejorar mantenibilidad

## üìù Convenciones de C√≥digo

### Nomenclatura
- **Idioma**: Ingl√©s para nombres de archivos, carpetas, clases,metodos, variables etc...
- **Convenci√≥n**: snake_case para archivos, PascalCase para clases, camelCase para variables
- **Consistencia**: Mantener coherencia en todo el proyecto

### Documentaci√≥n y Comentarios
- **Funciones**: Documentar solo funciones complejas o no autoexplicativas (1-2 l√≠neas m√°ximo)
- **Idioma**: Comentarios y documentaci√≥n en espa√±ol
- **Comentarios**: Explicar secciones complejas o no evidentes
- **Evitar**: Comentarios redundantes o innecesarios

## ü§ñ Desarrollo Asistido por IA (Copilot)

### Mejores Pr√°cticas con IA
- **C√≥digo descriptivo**: Escribir nombres de funciones y variables descriptivos para que la IA comprenda mejor el contexto
- **Comentarios estrat√©gicos**: Usar comentarios antes de funciones complejas para guiar la IA
- **Patrones consistentes**: Mantener patrones de c√≥digo consistentes para mejorar las sugerencias
- **Contexto claro**: Proporcionar suficiente contexto en archivos para que la IA genere c√≥digo apropiado

### Optimizaci√≥n para Sugerencias IA
```dart
// ‚úÖ Buena pr√°ctica - Nombres descriptivos
Future<List<Product>> fetchActiveProductsFromCatalogue() async {
  // Obtener productos activos del cat√°logo con filtros aplicados
  return await catalogueRepository.getActiveProducts();
}

// ‚ùå Evitar - Nombres gen√©ricos
Future<List<dynamic>> getData() async {
  return await repo.get();
}
```

### Prompts Efectivos para IA
- Especificar el tipo de widget/componente Flutter deseado
- Mencionar Material 3 y Clean Architecture en las solicitudes
- Incluir contexto de la capa (presentation, domain, data)
- Solicitar implementaciones con Provider cuando sea necesario

## üîß Debugging y Herramientas

### Flutter DevTools
- **Inspector**: Usar para analizar el √°rbol de widgets y detectar problemas de UI
- **Performance**: Monitorear rendimiento y detectar rebuilds innecesarios
- **Memory**: Identificar memory leaks en widgets y providers
- **Network**: Supervisar llamadas HTTP y APIs

### Estrategias de Debug
```dart
// Logging estructurado para debugging
import 'package:flutter/foundation.dart';

void debugLog(String message, {String? tag}) {
  if (kDebugMode) {
    print('[${tag ?? 'DEBUG'}] ${DateTime.now()}: $message');
  }
}

// Debug espec√≠fico por capas
class RepositoryLogger {
  static void logApiCall(String endpoint, Map<String, dynamic>? data) {
    debugLog('API Call: $endpoint with data: $data', tag: 'REPOSITORY');
  }
}
```


### Herramientas de Calidad
- **flutter analyze**: Ejecutar antes de cada commit
- **dart format**: Formateo autom√°tico del c√≥digo
- **flutter test --coverage**: Mantener cobertura >80%
- **very_good_analysis**: Lint rules estrictas

## ‚ö° Performance y Optimizaci√≥n

### Optimizaci√≥n de Widgets
```dart
// ‚úÖ Usar const constructors cuando sea posible
class ProductCard extends StatelessWidget {
  const ProductCard({
    super.key,
    required this.product,
  });
  
  final Product product;
  
  @override
  Widget build(BuildContext context) {
    return const Card(
      // Widget inmutable optimizado
    );
  }
}

// ‚úÖ Implementar shouldRebuild en Providers
class CatalogueProvider extends ChangeNotifier {
  @override
  bool shouldRebuild(covariant CatalogueProvider oldWidget) {
    return products != oldWidget.products;
  }
}
```

### Manejo de Estado Eficiente
- **Consumer granular**: Usar Consumer espec√≠ficos en lugar de Consumer generales
- **Selector widgets**: Implementar Selector para rebuilds optimizados
- **Provider.of(listen: false)**: Para acciones que no requieren rebuild
- **MultiProvider**: Organizar providers de manera jer√°rquica

### Lazy Loading y Paginaci√≥n
```dart
// Implementar paginaci√≥n en listas grandes
class PaginatedProductList extends StatefulWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: products.length + (hasMore ? 1 : 0),
      itemBuilder: (context, index) {
        if (index == products.length) {
          // Trigger para cargar m√°s elementos
          _loadMoreProducts();
          return const CircularProgressIndicator();
        }
        return ProductTile(product: products[index]);
      },
    );
  }
}
```

## üîí Seguridad y Manejo de Errores

### Error Handling Robusto
```dart
// Implementar Result pattern para manejo de errores
abstract class Failure {
  final String message;
  const Failure(this.message);
}

class NetworkFailure extends Failure {
  const NetworkFailure() : super('Error de conexi√≥n');
}

// Uso en repositorios
Future<Either<Failure, List<Product>>> getProducts() async {
  try {
    final response = await apiClient.get('/products');
    return Right(ProductMapper.fromJson(response.data));
  } on SocketException {
    return const Left(NetworkFailure());
  } catch (e) {
    return Left(UnknownFailure(e.toString()));
  }
}
```

### Validaci√≥n de Datos
- Implementar validadores en el domain layer
- Usar freezed para objetos inmutables
- Validar inputs en tiempo real en la UI
- Sanitizar datos antes de enviar a APIs

## üì± Responsive y Adaptativo

### Dise√±o Responsivo
```dart
// Breakpoints para diferentes tama√±os
class Breakpoints {
  static const double mobile = 600;
  static const double tablet = 1024;
  static const double desktop = 1440;
}

// Layout adaptativo
Widget buildResponsiveLayout(BuildContext context) {
  return LayoutBuilder(
    builder: (context, constraints) {
      if (constraints.maxWidth < Breakpoints.mobile) {
        return const MobileLayout();
      } else if (constraints.maxWidth < Breakpoints.tablet) {
        return const TabletLayout();
      } else {
        return const DesktopLayout();
      }
    },
  );
}
```

## ‚úÖ Buenas Pr√°cticas Generales
- **Inmutabilidad**: Usar objetos inmutables con freezed cuando sea posible
- **Separation of Concerns**: Cada clase/funci√≥n tiene una √∫nica responsabilidad
- **DRY Principle**: Evitar duplicaci√≥n de c√≥digo mediante componentes reutilizables
- **KISS Principle**: Mantener soluciones simples y directas
- **Progressive Enhancement**: Construir funcionalidad base primero, luego mejorar
- **Code Review**: Revisar c√≥digo antes de merge, enfoc√°ndose en arquitectura y performance
- **Documentation**: Documentar decisiones arquitect√≥nicas importantes
- **Version Control**: Commits at√≥micos con mensajes descriptivos en Espa√±ol

## üõ†Ô∏è Herramientas y Configuraci√≥n

### Extensiones VS Code Recomendadas
```json
{
  "recommendations": [
    "dart-code.flutter",
    "dart-code.dart-code",
    "github.copilot",
    "github.copilot-chat",
    "ms-vscode.vscode-json",
    "bradlc.vscode-tailwindcss",
    "usernamehw.errorlens",
    "aaron-bond.better-comments"
  ]
}
```

### Configuraci√≥n launch.json
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Flutter Web Debug",
      "type": "dart",
      "request": "launch",
      "program": "lib/main.dart",
      "deviceId": "chrome",
      "args": ["--web-port", "3000"]
    },
    {
      "name": "Flutter Web Profile",
      "type": "dart",
      "request": "launch",
      "program": "lib/main.dart",
      "deviceId": "chrome",
      "flutterMode": "profile"
    }
  ]
}
```

### Scripts de Automatizaci√≥n
```json
// package.json scripts recomendados
{
  "scripts": {
    "analyze": "flutter analyze",
    "format": "dart format .",
    "test": "flutter test --coverage",
    "build": "flutter build web --release",
    "serve": "flutter run -d chrome --web-port 3000"
  }
}
```

### Configuraci√≥n analysis_options.yaml
```yaml
include: package:very_good_analysis/analysis_options.yaml

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
  strong-mode:
    implicit-casts: false
    implicit-dynamic: false

linter:
  rules:
    prefer_const_constructors: true
    prefer_const_literals_to_create_immutables: true
    avoid_print: true
    prefer_single_quotes: true
```

## üìã Checklist de Desarrollo

### Antes de Empezar una Feature
- [ ] Definir interfaces en domain layer
- [ ] Crear entidades y DTOs necesarios
- [ ] Implementar casos de uso
- [ ] Configurar providers necesarios
- [ ] Dise√±ar UI siguiendo Material 3

### Antes de Commit
- [ ] Ejecutar `flutter analyze` sin errores
- [ ] Ejecutar `dart format .`
- [ ] Correr tests unitarios y de widgets
- [ ] Verificar que no hay console.log o print() innecesarios
- [ ] Comprobar que los nombres est√°n en ingl√©s
- [ ] Documentar funciones complejas en espa√±ol

### Antes de Deploy
- [ ] Testing en m√∫ltiples tama√±os de pantalla
- [ ] Verificar tema claro/oscuro
- [ ] Optimizar assets e im√°genes
- [ ] Revisar bundle size 
- [ ] Validar accesibilidad b√°sica

--- 